" vimconf is not vi-compatible
set nocompatible

" vundle plugin manager
call plug#begin('~/.vim/plugged')         " init vimplug

" colorscheme
Plug 'nanotech/jellybeans.vim'

" statusline
Plug 'itchyny/lightline.vim'
Plug 'bling/vim-bufferline'
Plug 'cocopon/lightline-hybrid.vim'

" split width fixer
Plug 'roman/golden-ratio'

" completion engine
Plug 'Shougo/neocomplete.vim'

" <Tab> everything
Plug 'ervandew/supertab'

" fuzzy finder
Plug 'kien/ctrlp.vim'

" git wrapper
Plug 'tpope/vim-fugitive'

" quickrun
Plug 'thinca/vim-quickrun'

" snippet engine and snippet repo 
Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'

" repeat everything
Plug 'tpope/vim-repeat'

" universal set of defaults
Plug 'tpope/vim-sensible'

" extended tpope vimrc
Plug 'tpope/vim-unimpaired'

" auto closes stuff
Plug 'jiangmiao/auto-pairs'

" surroundings
Plug 'tpope/vim-surround'

" align everything
Plug 'junegunn/vim-easy-align'

" racket language support
Plug 'wlangstroth/vim-racket', { 'for': ['racket'] }
command Racket !drracket %

" check syntax
Plug 'scrooloose/syntastic'

call plug#end()

" syntax highlighting
filetype plugin indent on           " detec file plugin + indent
syntax on                           " turn on syntax highlight
set background=dark                 " we're using a dark bg
colorscheme jellybeans
set t_Co=16
set encoding=UTF-8
set formatoptions+=t                " autowrap with newline char
set tw=79                           " autowrap length is 79 col
augroup FileTypeRules
    autocmd!
    autocmd BufNewFile,BufRead *.conf set ft=cfg tw=79
    autocmd BufNewFile,BufRead *.md set ft=markdown tw=79
    autocmd BufNewFile,BufRead *.tex set ft=tex tw=79
    autocmd BufNewFile,BufRead *.txt set ft=sh tw=79
augroup END
augroup vimrc_autocmds              " sets background to red if text >= 80 col
  autocmd BufEnter * highlight OverLength ctermbg=darkred guibg=#592929
  autocmd BufEnter * match OverLength /\%81v.*/
augroup END

" interface general
set cursorline                      " hilight cursor line
set more                            " ---more--- like less
set number                          " line numbers are good
set scrolloff=8
set sidescrolloff=15
set sidescroll=1
set showcmd                         " show cmds being typed
set title                           " window title
set vb t_vb=                        " disable beep and flashing
set wildignore=*.a,*.o,*.so,*.pyc,*.jpg,
            \*.jpeg,*.png,*.gif,*.pdf,*.git,
            \*.swp,*.swo            " tab completion ignores

set wildignore=*.o,*.obj,*~
set wildignore+=*vim/backups*
set wildignore+=*sass-cache*
set wildignore+=*DS_Store*
set wildignore+=vendor/rails/**
set wildignore+=vendor/cache/**
set wildignore+=*.gem
set wildignore+=log/**
set wildignore+=tmp/**
set wildignore+=*.png,*.jpg,*.gif

set wildmenu                        " better auto complete
set wildmode=longest,list           " bash-like auto complete

" general settings
set hidden
set history=1000         " Store lots of :cmdline history
set iskeyword+=_,$,@,%,# " not word dividers
set laststatus=2         " always show statusline
set linebreak            " dont cut words on wrap
set list listchars=tab:\ ▸\,trail:·,eol:¬ " highlight listchars
set mouse=               " disable mouse
set noshowmode           " hide mode cmd line
set noexrc               " dont use other .*rc(s)
set nostartofline        " keep cursor column pos
set nowrap               " dont wrap lines
set numberwidth=5        " 99999 lines
set shortmess+=I         " disable startup message
set splitbelow           "splits go below w/focus
set splitright           " vsplits go right w/focus
set ttyfast              " for faster redraws

" folding
set foldlevelstart=0
set foldcolumn=0         " hide folding column
set foldmethod=syntax    " folds using syntax
set foldnestmax=10       " max 10 nested folds
" set foldlevelstart=99  " folds open by default
set foldlevelstart=1     " folds closed by default
nnoremap <Space> za
vnoremap <Space> za

" Search and replace
set gdefault " default s//g (global)
set incsearch " 'live'-search
" set hlsearch " highlight all search matches

" Matching
set matchtime=2 " time to blink match {}
set matchpairs+=<:> " for ci< or ci>
set showmatch " tmpjump to match-bracket

" files
set autoread                    "Reload files changed outside vim
set nobackup
set nowb

" Persistent Undo
if has('persistent_undo')
    silent !mkdir ~/.vim/backups > /dev/null 2>&1
    set undodir=~/.vim/backups
    set undofile
    set undolevels=500
    set undoreload=10000
endif

" text formating
set autoindent
set ignorecase
set smartcase
set backspace=indent,eol,start  "Allow backspace in insert mode
set smartindent
set expandtab
set shiftround
set smarttab
set shiftwidth=4
set tabstop=4
set softtabstop=4
set nojoinspaces

" keybinds
" Remap <leader>
let mapleader=","

" disable ex mode
nnoremap Q <nop>

" yank/paste/delete to system keyboard
noremap <leader>y "+y
noremap <leader>d "+d
noremap <leader>p "+p
noremap <leader>P "+P

" Treat wrapped lines as normal lines
nnoremap j gj
nnoremap k gk

" Working ci(, works for both breaklined, inline and multiple ()
nnoremap ci( %ci(

" plugin settings
" Lightline
let g:lightline = {
            \ 'colorscheme': 'hybrid',
            \ 'active': {
            \ 'left': [
            \ ['mode', 'paste'],
            \ ['readonly', 'fugitive'],
            \ ['ctrlpmark', 'bufferline']
            \ ],
            \ 'right': [
            \ ['lineinfo'],
            \ ['percent'],
            \ ['fileformat', 'fileencoding', 'filetype', 'syntastic']
            \ ]
            \ },
            \ 'component': {
            \ 'paste': '%{&paste?"!":""}'
            \ },
            \ 'component_function': {
            \ 'mode' : 'MyMode',
            \ 'fugitive' : 'MyFugitive',
            \ 'readonly' : 'MyReadonly',
            \ 'ctrlpmark' : 'CtrlPMark',
            \ 'bufferline' : 'MyBufferline',
            \ 'fileformat' : 'MyFileformat',
            \ 'fileencoding' : 'MyFileencoding',
            \ 'filetype' : 'MyFiletype'
            \ },
            \ 'component_expand': {
            \ 'syntastic': 'SyntasticStatuslineFlag',
            \ },
            \ 'component_type': {
            \ 'syntastic': 'middle',
            \ },
            \ 'subseparator': {
            \ 'left': '|', 'right': '|'
            \ }
            \ }

let g:lightline.mode_map = {
            \ 'n' : ' N ',
            \ 'i' : ' I ',
            \ 'R' : ' R ',
            \ 'v' : ' V ',
            \ 'V' : 'V-L',
            \ 'c' : ' C ',
            \ "\<C-v>" : 'V-B',
            \ 's' : ' S ',
            \ 'S' : 'S-L',
            \ "\<C-s>" : 'S-B',
            \ '?' : ' ' }

function! MyMode()
    let fname = expand('%:t')
    return fname == '__Tagbar__' ? 'Tagbar' :
                \ fname == 'ControlP' ? 'CtrlP' :
                \ winwidth('.') > 60 ? lightline#mode() : ''
endfunction

function! MyFugitive()
    try
        if expand('%:t') !~? 'Tagbar' && exists('*fugitive#head')
            let mark = '± '
            let _ = fugitive#head()
            return strlen(_) ? mark._ : ''
        endif
    catch
    endtry
    return ''
endfunction

function! MyReadonly()
    return &ft !~? 'help' && &readonly ? '≠' : '' " or ⭤
endfunction

function! CtrlPMark()
    if expand('%:t') =~ 'ControlP'
        call lightline#link('iR'[g:lightline.ctrlp_regex])
        return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
                    \ , g:lightline.ctrlp_next], 0)
    else
        return ''
    endif
endfunction

function! MyBufferline()
    call bufferline#refresh_status()
    let b = g:bufferline_status_info.before
    let c = g:bufferline_status_info.current
    let a = g:bufferline_status_info.after
    let alen = strlen(a)
    let blen = strlen(b)
    let clen = strlen(c)
    let w = winwidth(0) * 4 / 11
    if w < alen+blen+clen
        let whalf = (w - strlen(c)) / 2
        let aa = alen > whalf && blen > whalf ? a[:whalf] : alen + blen < w - clen || alen < whalf ? a : a[:(w - clen - blen)]
        let bb = alen > whalf && blen > whalf ? b[-(whalf):] : alen + blen < w - clen || blen < whalf ? b : b[-(w - clen - alen):]
        return (strlen(bb) < strlen(b) ? '...' : '') . bb . c . aa . (strlen(aa) < strlen(a) ? '...' : '')
    else
        return b . c . a
    endif
endfunction

function! MyFileformat()
    return winwidth('.') > 90 ? &fileformat : ''
endfunction

function! MyFileencoding()
    return winwidth('.') > 80 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyFiletype()
    return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

let g:ctrlp_status_func = {
            \ 'main': 'CtrlPStatusFunc_1',
            \ 'prog': 'CtrlPStatusFunc_2',
            \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
    let g:lightline.ctrlp_regex = a:regex
    let g:lightline.ctrlp_prev = a:prev
    let g:lightline.ctrlp_item = a:item
    let g:lightline.ctrlp_next = a:next
    return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
    return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
    return lightline#statusline(0)
endfunction

function! s:syntastic()
    SyntasticCheck
    call lightline#update()
endfunction

augroup AutoSyntastic
    autocmd!
    autocmd BufWritePost *.c,*.cpp,*.perl,*py,*.rkt call s:syntastic()
augroup END

" bufferline
let g:bufferline_echo = 0

" ctrlp
let g:ctrlp_match_window = 'bottom,order:ttb'
let g:ctrlp_switch_buffer = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'

" ultisnip
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
let g:UltiSnipsEditSplit="vertical"

" syntastic
let g:syntastic_cpp_check_header = 1
let g:syntastic_cpp_compiler_options = ' -std=c++0x'
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 1

" neocomplete
let g:acp_enableAtStartup = 0 " Disable AutoComplPop.
let g:neocomplete#enable_at_startup = 1 " Use neocomplete.
let g:neocomplete#enable_smart_case = 1 " Use smartcase.
let g:neocomplete#sources#syntax#min_keyword_length = 3 " Set minimum syntax keyword length.
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" easyalign
vmap <Enter> <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" Netrw - the bundled (network) file and directory browser
let g:netrw_banner = 0
let g:netrw_list_hide = '^\.$'
let g:netrw_liststyle = 3

" vim-hardtime
let g:hardtime_default_on = 0
