" vimconf is not vi-compatible
set nocompatible

" vundle plugin manager
filetype off                            " required to init
set rtp+=~/.vim/bundle/Vundle.vim       " include vundle
call vundle#begin()                     " init vundle

" vundle
Plugin 'gmarik/Vundle.vim'

" hybrid colorscheme
Plugin 'w0ng/vim-hybrid'

" statusline
Plugin 'itchyny/lightline.vim'
Plugin 'bling/vim-bufferline'

" fuzzy finder
Plugin 'kien/ctrlp.vim'

" <Tab> everything
Plugin 'ervandew/supertab'

" universal set of defaults
Plugin 'tpope/vim-sensible.git'

" extended tpope vimrc
Plugin 'tpope/vim-unimpaired.git'

" git wrapper
Plugin 'tpope/vim-fugitive.git'

" gists
Plugin 'mattn/gist-vim.git'

" repeat everything
Plugin 'tpope/vim-repeat.git'

" end structures automatically
Plugin 'tpope/vim-endwise.git'

" working with variants of a word
Plugin 'tpope/vim-abolish.git'

" auto closes stuff
Plugin 'jiangmiao/auto-pairs.git'

" surroundings
Plugin 'tpope/vim-surround.git'

" super commenter
Plugin 'scrooloose/nerdcommenter.git'

" align everything
Plugin 'vim-scripts/Align'

" racket language support
Plugin 'wlangstroth/vim-racket.git'

command Racket !drracket %

" latex support
" Plugin 'LaTeX-Box-Team/LaTeX-Box'
" Plugin 'lervag/vim-latex'

" snippet engine
Plugin 'SirVer/ultisnips'

" snippet repo
Plugin 'honza/vim-snippets'

" check syntax
Plugin 'scrooloose/syntastic.git'

" breaking habits and taking names
Plugin 'takac/vim-hardtime'

" end plugin call
call vundle#end()

" syntax highlighting
filetype plugin indent on           " detec file plugin + indent
syntax on                           " turn on syntax highlight
set background=dark                 " we're using a dark bg
colorscheme hybrid                  " colorscheme
let g:hybrid_use_Xresources = 1     " let colorscheme use xresources
set encoding=UTF-8
augroup FileTypeRules
    autocmd!
    autocmd BufNewFile,BufRead *.conf set ft=cfg tw=79
    autocmd BufNewFile,BufRead *.md set ft=markdown tw=79
    autocmd BufNewFile,BufRead *.tex set ft=tex tw=79
    autocmd BufNewFile,BufRead *.txt set ft=sh tw=79
augroup END

" interface general
set cursorline                      " hilight cursor line
set more                            " ---more--- like less
set number                          " line numbers are good
set scrolloff=8
set sidescrolloff=15
set sidescroll=1
set showcmd                         " show cmds being typed
set title                           " window title
set vb t_vb=                        " disable beep and flashing
set wildignore=*.a,*.o,*.so,*.pyc,*.jpg,
            \*.jpeg,*.png,*.gif,*.pdf,*.git,
            \*.swp,*.swo            " tab completion ignores

set wildignore=*.o,*.obj,*~
set wildignore+=*vim/backups*
set wildignore+=*sass-cache*
set wildignore+=*DS_Store*
set wildignore+=vendor/rails/**
set wildignore+=vendor/cache/**
set wildignore+=*.gem
set wildignore+=log/**
set wildignore+=tmp/**
set wildignore+=*.png,*.jpg,*.gif

set wildmenu                        " better auto complete
set wildmode=longest,list           " bash-like auto complete

" general settings
set hidden
set history=1000                "Store lots of :cmdline history
set iskeyword+=_,$,@,%,# " not word dividers
set laststatus=2 " always show statusline
set linebreak " dont cut words on wrap
set list listchars=tab:\ ▸\,trail:·,eol:¬ " highlight listchars
set mouse= " disable mouse
set noshowmode " hide mode cmd line
set noexrc " dont use other .*rc(s)
set nostartofline " keep cursor column pos
set nowrap " dont wrap lines
set numberwidth=5 " 99999 lines
set shortmess+=I " disable startup message
set splitbelow "splits go below w/focus
set splitright " vsplits go right w/focus
set ttyfast " for faster redraws

" folding
set foldlevelstart=0
set foldcolumn=0 " hide folding column
set foldmethod=indent " folds using indent
set foldnestmax=10 " max 10 nested folds
set foldlevelstart=99 "folds open by default
nnoremap <Space> za
vnoremap <Space> za

" Search and replace
set gdefault " default s//g (global)
set incsearch " "live"-search
set hlsearch " highlight all search matches

" Matching
set matchtime=2 " time to blink match {}
set matchpairs+=<:> " for ci< or ci>
set showmatch " tmpjump to match-bracket

" files
set autoread                    "Reload files changed outside vim
set nobackup
set nowb

" Persistent Undo
if has('persistent_undo')
    silent !mkdir ~/.vim/backups > /dev/null 2>&1
    set undodir=~/.vim/backups
    set undofile
    set undolevels=500
    set undoreload=10000
endif

" text formating
set autoindent
set ignorecase
set smartcase
set backspace=indent,eol,start  "Allow backspace in insert mode
set smartindent
set expandtab
set shiftround
set smarttab
set shiftwidth=4
set tabstop=4
set softtabstop=4
set nojoinspaces

" keybinds
" Remap <leader>
let mapleader=","

" disable ex mode
nnoremap Q <nop>

" yank/paste/delete to system keyboard
noremap <leader>y "+y
noremap <leader>d "+d
noremap <leader>p "+p
noremap <leader>P "+P

" Treat wrapped lines as normal lines
nnoremap j gj
nnoremap k gk

" Working ci(, works for both breaklined, inline and multiple ()
nnoremap ci( %ci(

" plugin settings
" Lightline
let g:lightline = {
            \ 'colorscheme': 'jellybeans',
            \ 'active': {
            \ 'left': [
            \ ['mode', 'paste'],
            \ ['readonly', 'fugitive'],
            \ ['ctrlpmark', 'bufferline']
            \ ],
            \ 'right': [
            \ ['lineinfo'],
            \ ['percent'],
            \ ['fileformat', 'fileencoding', 'filetype', 'syntastic']
            \ ]
            \ },
            \ 'component': {
            \ 'paste': '%{&paste?"!":""}'
            \ },
            \ 'component_function': {
            \ 'mode' : 'MyMode',
            \ 'fugitive' : 'MyFugitive',
            \ 'readonly' : 'MyReadonly',
            \ 'ctrlpmark' : 'CtrlPMark',
            \ 'bufferline' : 'MyBufferline',
            \ 'fileformat' : 'MyFileformat',
            \ 'fileencoding' : 'MyFileencoding',
            \ 'filetype' : 'MyFiletype'
            \ },
            \ 'component_expand': {
            \ 'syntastic': 'SyntasticStatuslineFlag',
            \ },
            \ 'component_type': {
            \ 'syntastic': 'middle',
            \ },
            \ 'subseparator': {
            \ 'left': '|', 'right': '|'
            \ }
            \ }

let g:lightline.mode_map = {
            \ 'n' : ' N ',
            \ 'i' : ' I ',
            \ 'R' : ' R ',
            \ 'v' : ' V ',
            \ 'V' : 'V-L',
            \ 'c' : ' C ',
            \ "\<C-v>" : 'V-B',
            \ 's' : ' S ',
            \ 'S' : 'S-L',
            \ "\<C-s>" : 'S-B',
            \ '?' : ' ' }

function! MyMode()
    let fname = expand('%:t')
    return fname == '__Tagbar__' ? 'Tagbar' :
                \ fname == 'ControlP' ? 'CtrlP' :
                \ winwidth('.') > 60 ? lightline#mode() : ''
endfunction

function! MyFugitive()
    try
        if expand('%:t') !~? 'Tagbar' && exists('*fugitive#head')
            let mark = '± '
            let _ = fugitive#head()
            return strlen(_) ? mark._ : ''
        endif
    catch
    endtry
    return ''
endfunction

function! MyReadonly()
    return &ft !~? 'help' && &readonly ? '≠' : '' " or ⭤
endfunction

function! CtrlPMark()
    if expand('%:t') =~ 'ControlP'
        call lightline#link('iR'[g:lightline.ctrlp_regex])
        return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
                    \ , g:lightline.ctrlp_next], 0)
    else
        return ''
    endif
endfunction

function! MyBufferline()
    call bufferline#refresh_status()
    let b = g:bufferline_status_info.before
    let c = g:bufferline_status_info.current
    let a = g:bufferline_status_info.after
    let alen = strlen(a)
    let blen = strlen(b)
    let clen = strlen(c)
    let w = winwidth(0) * 4 / 11
    if w < alen+blen+clen
        let whalf = (w - strlen(c)) / 2
        let aa = alen > whalf && blen > whalf ? a[:whalf] : alen + blen < w - clen || alen < whalf ? a : a[:(w - clen - blen)]
        let bb = alen > whalf && blen > whalf ? b[-(whalf):] : alen + blen < w - clen || blen < whalf ? b : b[-(w - clen - alen):]
        return (strlen(bb) < strlen(b) ? '...' : '') . bb . c . aa . (strlen(aa) < strlen(a) ? '...' : '')
    else
        return b . c . a
    endif
endfunction

function! MyFileformat()
    return winwidth('.') > 90 ? &fileformat : ''
endfunction

function! MyFileencoding()
    return winwidth('.') > 80 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyFiletype()
    return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

let g:ctrlp_status_func = {
            \ 'main': 'CtrlPStatusFunc_1',
            \ 'prog': 'CtrlPStatusFunc_2',
            \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
    let g:lightline.ctrlp_regex = a:regex
    let g:lightline.ctrlp_prev = a:prev
    let g:lightline.ctrlp_item = a:item
    let g:lightline.ctrlp_next = a:next
    return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
    return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
    return lightline#statusline(0)
endfunction

function! s:syntastic()
    SyntasticCheck
    call lightline#update()
endfunction

augroup AutoSyntastic
    autocmd!
    autocmd BufWritePost *.c,*.cpp,*.perl,*py,*.rkt call s:syntastic()
augroup END

" bufferline
let g:bufferline_echo = 0

" ctrlp
let g:ctrlp_clear_cache_on_exit = 0
let g:ctrlp_working_path_mode = 'ra'

" ultisnip
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
let g:UltiSnipsEditSplit="vertical"

" syntastic
let g:syntastic_cpp_check_header = 1
let g:syntastic_cpp_compiler_options = ' -std=c++0x'
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 1

" Netrw - the bundled (network) file and directory browser
let g:netrw_banner = 0
let g:netrw_list_hide = '^\.$'
let g:netrw_liststyle = 3

" vim-hardtime
let g:hardtime_default_on = 0
